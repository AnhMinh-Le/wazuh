#include <algorithm>
#include <stdio.h>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>
#include <memory>

#include <curl/curl.h>

#include "rapidjson/document.h"
#include "rapidjson/error/en.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"


enum class CombType {
    Null,
    Optional,
    Or,
    OrEnd,
    Invalid,
};

enum class ParserType {
    Any,
    Literal,
    IP,
    Ts,
    URL,
    JSON,
    Invalid,
};

struct Parser {
    std::vector<std::string> captureOpts; // TODO The options include the name on the first slot
                                          // This is probably not the best way but works so far
    ParserType parserType;
    CombType combType;
    char endToken;
};

static const std::unordered_map<std::string_view, ParserType> ECSParserMapper {
    { "url", ParserType::URL},
    { "source.ip", ParserType::Any },
    { "timestamp", ParserType::Any },
    { "http.request.method", ParserType::Any },
    { "json", ParserType::JSON },
};

struct Tokenizer {
    const char *stream;
};

enum class TokenType {
    _EndOfAscii = 256,
    OpenAngle,
    CloseAngle,
    QuestionMark,
    Literal,
    EndOfExpr,
    Unknown,
    Error,
};

struct Token {
    const char *text;
    size_t len;
    TokenType type;
};

static Token getToken(Tokenizer &tk) {
    const char *c = tk.stream++;

    switch (c[0]) {
        case '<': return { "<", 1, TokenType::OpenAngle };
        case '>': return { ">", 1, TokenType::CloseAngle };
        case '?': return { "?", 1, TokenType::QuestionMark };
        case '\0': return { 0, 0, TokenType::EndOfExpr };
        default: {
            bool escaped = false;
            while (tk.stream[0] && (escaped || (tk.stream[0] != '<' && tk.stream[0] != '>'))) {
                tk.stream++;
                escaped = tk.stream[0] == '\\';
            }
            return { c, static_cast<size_t>(tk.stream - c), TokenType::Literal };
        }
    }

    // TODO unreachable
    return { 0, 0, TokenType::Unknown };
}

bool requireToken(Tokenizer &tk, TokenType req) {
    return getToken(tk).type == req;
}

Token peekToken(Tokenizer const &tk) {
    Tokenizer tmp { tk.stream };
    return getToken(tmp);
}

char peekChar(Tokenizer const &tk) {
    return tk.stream[0];
}

std::vector<std::string> splitSlashSeparatedField(std::string_view str){
    std::vector<std::string> ret;
    while (true) {
        auto pos = str.find('/');
        if (pos == str.npos) {
            break;
        }
        ret.emplace_back(str.substr(0, pos));
        str = str.substr(pos + 1);
    }

    if (!str.empty()) {
        ret.emplace_back(str);
    }

    return ret;
}

static Parser parseCaptureString(Token token) {
    // TODO assert token type
    ParserType type = ParserType::Any;
    std::vector<std::string> captureOpts;

    if (token.text[0] == '_') {
        // We could be parsing:
        //      '<_>'
        //      '<_name>'
        //      '<_name/type>'
        //      '<_name/type/type2>'
        if (token.len != 1) {
            captureOpts = splitSlashSeparatedField({ token.text, token.len });
        }
    }
    else {
        captureOpts = splitSlashSeparatedField({ token.text, token.len });

        auto it = ECSParserMapper.find({ token.text, token.len });
        if (it != ECSParserMapper.end()) {
            type = it->second;
        }
    }

    return { std::move(captureOpts), type, CombType::Null, 0 };
}

static void parseCapture(Tokenizer &tk, ParserList &parsers) {
    //<name> || <?name> || <name1>?<name2>
    Token token = getToken(tk);
    bool optional = false;
    if (token.type == TokenType::QuestionMark) {
        optional = true;
        token = getToken(tk);
    }

    if (token.type == TokenType::Literal) {
        parsers.emplace_back(parseCaptureString(token));

        if (!requireToken(tk, TokenType::CloseAngle)) {
            // TODO report parsing error
            return;
        }

        if (peekToken(tk).type == TokenType::QuestionMark) {
            // We are parsing <name1>?<name2>
            // Discard the peeked '?'
            getToken(tk);

            if (!requireToken(tk, TokenType::OpenAngle)) {
                // TODO report error
                return;
            }
            // Fix up the combType of the previous capture as this is now an OR
            auto &prevCapture = parsers.back();
            prevCapture.combType = CombType::Or;

            parsers.emplace_back(parseCaptureString(token));
            auto &currentCapture = parsers.back();
            currentCapture.combType = CombType::OrEnd;

            if (!requireToken(tk, TokenType::CloseAngle)) {
                // TODO report error
                return;
            }

            char endToken = peekChar(tk);
            currentCapture.endToken = endToken;
            prevCapture.endToken = endToken;
        }
        else {
            // TODO Check if there's a better way to do this
            parsers.back().endToken = peekChar(tk);
        }
    }
    else {
        // TODO error
    }
}

ParserList parseLogQlExpr(std::string const &expr) {
    std::vector<Parser> parsers;
    Tokenizer tokenizer { expr.c_str() };

    bool done = false;
    while (!done) {
        Token token = getToken(tokenizer);
        switch (token.type) {
            case TokenType::OpenAngle: {
                parseCapture(tokenizer, parsers);
                if(peekToken(tokenizer).type == TokenType::OpenAngle){
                    //TODO report error. Can't have two captures back to back
                    fprintf(stderr, "Invalid logQl expresion. Can't have captures back to back\n");
                    done = true;
                }
                break;
            }
            case TokenType::Literal: {
                parsers.push_back({ { { token.text, token.text + token.len } },
                                    ParserType::Literal,
                                    CombType::Null,
                                    0 });
                break;
            }
            case TokenType::EndOfExpr: {
                done = true;
                break;
            }
            default: {
                // TODO
                break;
            }
        }
    }

    return parsers;
}

using ParseResult = std::unordered_map<std::string, std::string>;

bool parseFilePath(const char **it, char endToken) {
    const char *start = *it;
    while (**it != endToken) { (*it)++; }
    return true;
}

struct URLResult{
    std::string domain;   //"url.domain": "keyword",
    std::string fragment; //"url.fragment": "keyword",
    std::string original; //"url.original": "keyword",
    std::string password; //"url.password": "keyword",
    std::string path;     //"url.path": "keyword",
    std::string port;     //"url.port": "long",
    std::string query;    //"url.query": "keyword",
    std::string scheme;   //"url.scheme": "keyword",
    std::string username; //"url.username": "keyword",
};

bool parseURL(const char **it, char endToken, URLResult &result) {
    const char *start = *it;
    // TODO Check how to handle if the URL contains the endToken
    while (**it != endToken) { (*it)++; }

    auto urlCleanup = [](auto *url) { curl_url_cleanup(url); };
    std::unique_ptr<CURLU, decltype(urlCleanup)> url { curl_url(), urlCleanup };

    if (url == nullptr) {
        // TODO error
        return false;
    }

    std::string urlStr { start, *it };
    auto uc = curl_url_set(url.get(), CURLUPART_URL, urlStr.c_str(), 0);
    if (uc) {
        fprintf(stderr, "Error setting URL to parse: [%s]\n", curl_url_strerror(uc));
        return false;
    }

    // TODO curl will parse and copy the URL into an allocated
    // char ptr and we will copy it again into the string for the result
    // Check if there's a way to avoid all the copying here
    char *str;
    uc = curl_url_get(url.get(), CURLUPART_URL, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.original = str;
    curl_free(str);

    uc = curl_url_get(url.get(), CURLUPART_HOST, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.domain = str;
    curl_free(str);

    uc = curl_url_get(url.get(), CURLUPART_PATH, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.path = str;
    curl_free(str);

    uc = curl_url_get(url.get(), CURLUPART_SCHEME, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.scheme = str;
    curl_free(str);

    uc = curl_url_get(url.get(), CURLUPART_USER, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.username = str;
    curl_free(str);

    uc = curl_url_get(url.get(), CURLUPART_PASSWORD, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.password = str;
    curl_free(str);

    uc = curl_url_get(url.get(), CURLUPART_QUERY, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.query = str;
    curl_free(str);

    uc = curl_url_get(url.get(), CURLUPART_PORT, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.port = str;
    curl_free(str);

    uc = curl_url_get(url.get(), CURLUPART_FRAGMENT, &str, 0);
    if (uc) {
        // TODO set an error someway
        return false;
    }
    result.fragment = str;
    curl_free(str);

    return true;
}

bool parseTimeStamp(char **it, char endToken) {
    return true;
}

std::string parseJson(const char **it, char endToken) {
    rapidjson::Document doc;

    if (doc.Parse<rapidjson::kParseStopWhenDoneFlag>(*it).HasParseError()) {
        // TODO error handling
        return {};
    }

    // TODO probably we are doing an extra copy of the original event to the string buffer
    // check how this really works to see if there's something we can do to avoid the copy
    rapidjson::StringBuffer s;
    rapidjson::Writer<rapidjson::StringBuffer> writer(s);
    doc.Accept(writer);

    // Advance the iterator on the actual size of the parsed json
    *it += s.GetLength();
    if (**it != endToken) {
        // TODO Error?
        return {};
    }

    return s.GetString();
};

std::string parseAny(const char **it, char endToken) {
    const char *start = *it;
    while (**it != endToken) { (*it)++; }
    return { start, *it };
}

bool matchLiteral(const char **it, std::string const& literal) {
    int i = 0;
    for (; (**it) && (i < literal.size());) {
        // Skip over the escaping '\'
        if (**it == '\\') {
            continue;
        }

        if (**it != literal[i]) {
            return false;
        }

        (*it)++;
        i++;
    }

    return literal[i] == '\0';
}

void executeParserList(std::string const &event, ParserList const &parsers, ParseResult &result) {
    const char *eventIt = event.c_str();

    // TODO This implementation is super simple for the POC
    // but we will want to re-do it or revise it to implement
    // better parser combinations
    bool error = false;
    printf("%30s | %4s | %4s | %4s\n", "Capture", "type", "comb", "etok");
    printf("-------------------------------|------|------|------\n");
    for (auto const &parser : parsers) {
        printf("%-30s | %4i | %4i | '%1c'\n",
               parser.captureOpts[0].c_str(),
               parser.parserType,
               parser.combType,
               parser.endToken);

        switch (parser.parserType) {
            case ParserType::Any: {
                auto ret = parseAny(&eventIt, parser.endToken, result);
                if (!ret.empty()) {
                    result[parser.captureOpts[0]] = ret;
                }
                else {
                    error = true;
                }
                break;
            }
            case ParserType::Literal: {
                if (!matchLiteral(&eventIt, parser.captureOpts[0])) {
                    fprintf(stderr, "Failed matching literal string\n");
                    error = true;
                }
                break;
            }
            case ParserType::URL: {
                URLResult urlResult;
                if (parseURL(&eventIt, parser.endToken, urlResult)) {
                    result["url.domain"] = std::move(urlResult.domain);
                    result["url.fragment"] = std::move(urlResult.fragment);
                    result["url.original"] = std::move(urlResult.original);
                    result["url.password"] = std::move(urlResult.password);
                    result["url.username"] = std::move(urlResult.username);
                    result["url.scheme"] = std::move(urlResult.scheme);
                    result["url.query"] = std::move(urlResult.query);
                    result["url.path"] = std::move(urlResult.path);
                    result["url.port"] = std::move(urlResult.port);
                }
                else{
                    error = true;
                }
                break;
            }
            case ParserType::JSON: {
                auto ret = parseJson(&eventIt, parser.endToken);
                if(!ret.empty()){
                    result["json"] = ret;
                }
                break;
            }
            default: {
                fprintf(stderr,
                        "Missing implementation for parser type: [%i]\n",
                        parser.parserType);
                break;
            }
        }

        if (error) {
            break;
        }
    }
}

auto getParserOp(std::string const &logQl) {
    auto parserList = parseLogQlExpr(logQl);

    auto parseFn = [expr = logQl, parserList = std::move(parserList)](std::string const &event) {
        printf("event:\n\t%s\n\t%s\n\n", event.c_str(), expr.c_str());
        ParseResult result;
        executeParserList(event, parserList, result);
        return result;
    };

    return parseFn;
}

static const char *logQl =
    "<source.address> - <json> - [<timestamp/APACHE>] \"<http.request.method> <url> HTTP/<http.version>\" "
    "<http.response.status_code> <http.response.body.bytes> \"-\" \"<user_agent.original>\"";
static const char *event =
    "monitoring-server - {\"data\":\"this is a json\"} - [29/May/2017:19:02:48 +0000] \"GET "
    "https://user:password@wazuh.com:8080/status?query=%22a%20query%20with%20a%20space%22#fragment "
    "HTTP/1.1\" 200 612 \"-\" \"Mozilla/5.0 (Windows NT 6.1; rv:15.0) Gecko/20120716 "
    "Firefox/15.0a2\"";

static const char *logQl2 = "<source.ip> - - [<timestamp/APACHE>] \"-\" "
                            "<http.response.status_code> <http.response.body.bytes> \"-\" \"-\"";
static const char *event2 = "127.0.0.1 - - [02/Feb/2019:05:38:45 +0100] \"-\" 408 152 \"-\" \"-\"";

static const char *logQl3 = "<source.ip><invalid>";
static const char *logQl4 = "<source.ip>?<_>";
static const char *logQl5 = "<_> <_temp> <_temp/type> <_temp/type/type2> <name/type> <name/type/type2>";

int main(int argc, char **argv) {

    auto parseOp = getParserOp(logQl);
    auto result = parseOp(event);
    putchar('\n');
    printf("%30s | %s\n", "Key", "Val");
    printf("-------------------------------|------------\n");
    for (auto const &r : result) { printf("%30s | %s\n", r.first.c_str(), r.second.c_str()); }

    putchar('\n');

    auto parseOp2 = getParserOp(logQl2);
    auto result2 = parseOp2(event2);
    putchar('\n');
    printf("%30s | %s\n", "Key", "Val");
    printf("-------------------------------|------------\n");
    for (auto const &r : result2) { printf("%30s | %s\n", r.first.c_str(), r.second.c_str()); }

    getParserOp(logQl3);
    getParserOp(logQl4);
    getParserOp(logQl5);

    return 0;
}
